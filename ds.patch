From 9e2b678e0c7d2ea6358ce0e577eb5699cba2e37d Mon Sep 17 00:00:00 2001
From: David James <james.n.david@gmail.com>
Date: Sat, 19 Apr 2014 12:27:58 -0500
Subject: [PATCH] MultiWindow

Change-Id: Ie5860c2105ad9c971157b41d65f8fab337461ef6
Signed-off-by: scott <scott@ubuntu>

Conflicts:
	core/java/android/app/Activity.java
	core/java/android/inputmethodservice/InputMethodService.java
	core/java/android/view/IWindowManager.aidl
	packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
	policy/src/com/android/internal/policy/impl/PhoneWindow.java
	services/java/com/android/server/wm/WindowManagerService.java
prevent multiwindow if halo enabled
please multiwindow stay out if HALO there !! , but we will leave you in activity

Change-Id: Ie9ca36b6c7647ff9c6f038986b107f3623d8726c
Signed-off-by: scott <scott@ubuntu>

Conflicts:

	core/java/android/inputmethodservice/InputMethodService.java

Conflicts:
	core/java/android/inputmethodservice/InputMethodService.java
[2/2] Frameworks: HALO

Forward port from jb.
PS1: Initial port
     Fix conficts with notification LED
     Fix derp
     Major derp
     HALO Mods
     Rebase
     Fix blackist, code clean and added some TODOs
PS2: Fix build
PS3: Fix bubble sometimes doesn't respond on new notification
PS4: Align halo icon

Change-Id: I3e79945433d61da090ca263f4e2989be9987f11d
Signed-off-by: Scott <scott@ubuntu>

Conflicts:
	core/java/android/app/INotificationManager.aidl
	core/java/android/app/Profile.aidl
	core/java/android/provider/Settings.java
	packages/SystemUI/AndroidManifest.xml
	packages/SystemUI/res/layout/status_bar_expanded_header.xml
	packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java
	packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
	services/java/com/android/server/NotificationManagerService.java
	services/java/com/android/server/am/ActivityStack.java

Conflicts:
	packages/SystemUI/res/values/bs_strings.xml
---
 core/java/android/app/Activity.java                | 113 +++++++++++
 core/java/android/app/ActivityManagerNative.java   |  24 +++
 core/java/android/app/IActivityManager.java        |   3 +
 core/java/android/content/Intent.java              |  13 ++
 .../inputmethodservice/InputMethodService.java     |  49 ++++-
 core/java/android/provider/Settings.java           |  67 +++++++
 core/java/android/view/IWindowManager.aidl         |  10 +
 packages/SystemUI/res/menu/recent_popup_menu.xml   |   1 +
 packages/SystemUI/res/values-zh-rCN/mk_strings.xml |  22 +++
 packages/SystemUI/res/values/mk_strings.xml        |  22 +++
 .../android/systemui/recent/RecentsActivity.java   |   7 +
 .../android/systemui/recent/RecentsPanelView.java  | 193 +++++++++++++++++-
 .../android/internal/policy/impl/PhoneWindow.java  |   3 +
 .../internal/policy/impl/PhoneWindowManager.java   |   4 +
 .../android/server/am/ActivityManagerService.java  | 109 ++++++++++-
 .../java/com/android/server/am/ActivityStack.java  |  21 +-
 .../android/server/wm/WindowManagerService.java    | 217 ++++++++++++++++++++-
 17 files changed, 867 insertions(+), 11 deletions(-)
 create mode 100644 packages/SystemUI/res/values-zh-rCN/mk_strings.xml
 create mode 100644 packages/SystemUI/res/values/mk_strings.xml

diff --git a/core/java/android/app/Activity.java b/core/java/android/app/Activity.java
index d6db8c2..9c8670f 100644
--- a/core/java/android/app/Activity.java
+++ b/core/java/android/app/Activity.java
@@ -39,6 +39,8 @@
 import android.database.Cursor;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
+import android.graphics.Point;
+import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.media.AudioManager;
 import android.net.Uri;
@@ -65,6 +67,9 @@
 import android.view.ContextMenu;
 import android.view.ContextMenu.ContextMenuInfo;
 import android.view.ContextThemeWrapper;
+import android.view.Display;
+import android.view.Gravity;
+import android.view.IWindowManager;
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
 import android.view.Menu;
@@ -764,6 +769,9 @@ public View findViewById(int id) {
     private Thread mUiThread;
     final Handler mHandler = new Handler();
 
+    private Rect mOriginalBounds;
+    private boolean mIsSplitView;
+
     /** Return the intent that started this activity. */
     public Intent getIntent() {
         return mIntent;
@@ -2455,6 +2463,14 @@ public boolean dispatchTouchEvent(MotionEvent ev) {
         if (ev.getAction() == MotionEvent.ACTION_DOWN) {
             onUserInteraction();
         }
+        if (mIsSplitView) {
+            IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+            try {
+                wm.notifyActivityTouched(mToken, false);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Cannot notify activity touched", e);
+            }
+        }
         if (getWindow().superDispatchTouchEvent(ev)) {
             return true;
         }
@@ -5220,12 +5236,108 @@ final void attach(Context context, ActivityThread aThread,
         }
         mWindowManager = mWindow.getWindowManager();
         mCurrentConfig = config;
+
+        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_SPLIT_VIEW) != 0) {
+            final IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+            updateSplitViewMetrics(true);
+        }
     }
 
     /** @hide */
     public final IBinder getActivityToken() {
         return mParent != null ? mParent.getActivityToken() : mToken;
     }
+    
+    /** @hide */
+    public final void setSplitViewRect(int l, int t, int r, int b) {
+        final IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+        /*try {
+            wm.setSplitViewRect(l,t,r,b);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Could not update split view rect", e);
+        }*/
+        updateSplitViewMetrics(false);
+    }
+
+    /** @hide */
+    public final boolean isSplitView() {
+        return mIsSplitView;
+    }
+
+    /** @hide */
+    final void updateSplitViewMetrics(boolean shouldReset) {
+        if (mParent != null) {
+            // Also update the parent activities, don't let the windows hanging
+            mParent.updateSplitViewMetrics(shouldReset);
+        }
+        
+        final IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+
+        try {
+            mIsSplitView = false;
+
+            if (shouldReset) {
+                wm.getSplitViewRect(getTaskId(), true);
+            }
+
+            // Check for split view settings
+            if (wm.isTaskSplitView(getTaskId())) {
+                // This activity/task is tagged as being in split view
+                mIsSplitView = true;
+
+                wm.setTaskChildSplit(mToken, true);
+
+                // Then, we apply it the position and size
+                mWindow.setGravity(Gravity.LEFT | Gravity.TOP);
+
+                WindowManager.LayoutParams params = mWindow.getAttributes();
+
+                // We save the original window size, in case we want to restore it later
+                if (mOriginalBounds == null) {
+                    mOriginalBounds = new Rect();
+                    mOriginalBounds.left = params.x;
+                    mOriginalBounds.top = params.y;
+                    mOriginalBounds.right = params.x + params.width;
+                    mOriginalBounds.bottom = params.y + params.height;
+                }
+                
+                /*try {
+                    wm.setSplitViewRect(mOriginalBounds.left, mOriginalBounds.top, mOriginalBounds.right, mOriginalBounds.bottom);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Could not update split view rect", e);
+                }*/
+
+                Rect windowBounds = wm.getSplitViewRect(getTaskId(), false);
+                mWindow.setLayout(windowBounds.right - windowBounds.left,
+                    windowBounds.bottom - windowBounds.top);
+
+                params.x = windowBounds.left;
+                params.y = windowBounds.top;
+                mWindow.setAttributes(params);
+
+                // Finally, we make the window non-modal to allow the second app to get input
+                mWindow.addFlags(WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL);
+                mWindow.addFlags(WindowManager.LayoutParams.FLAG_SPLIT_TOUCH);
+
+                // We notify that we are touched -- but really it's just so that this activity
+                // which just opened has the focus without the need to touch it
+                wm.notifyActivityTouched(mToken, true);
+            } else if (mOriginalBounds != null) {
+                // Restore normal window bounds
+                Log.d(TAG, "Restore original bounds from split (TaskId=" + getTaskId() + ")");
+                WindowManager.LayoutParams params = mWindow.getAttributes();
+                params.x = mOriginalBounds.left;
+                params.y = mOriginalBounds.top;
+
+                mWindow.setLayout(mOriginalBounds.right - mOriginalBounds.left,
+                    mOriginalBounds.bottom - mOriginalBounds.top);
+
+                wm.setTaskChildSplit(mToken, false);
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "Could not perform split view actions on restart", e);
+        }
+    }
 
     final void performCreate(Bundle icicle) {
         onCreate(icicle);
@@ -5261,6 +5373,7 @@ final void performStart() {
     
     final void performRestart() {
         mFragments.noteStateNotSaved();
+        updateSplitViewMetrics(false);
 
         if (mStopped) {
             mStopped = false;
diff --git a/core/java/android/app/ActivityManagerNative.java b/core/java/android/app/ActivityManagerNative.java
index a6ca70c..456feac 100644
--- a/core/java/android/app/ActivityManagerNative.java
+++ b/core/java/android/app/ActivityManagerNative.java
@@ -693,6 +693,16 @@ public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
             return true;
         }
 
+        case GET_ACTIVITY_FOR_TASK_TRANSACTION: {
+            data.enforceInterface(IActivityManager.descriptor);
+            int task = data.readInt();
+            boolean onlyRoot = data.readInt() != 0;
+            IBinder res = getActivityForTask(task, onlyRoot);
+            reply.writeNoException();
+            reply.writeStrongBinder(res);
+            return true;
+        }
+
         case REPORT_THUMBNAIL_TRANSACTION: {
             data.enforceInterface(IActivityManager.descriptor);
             IBinder token = data.readStrongBinder();
@@ -2850,6 +2860,20 @@ public int getTaskForActivity(IBinder token, boolean onlyRoot) throws RemoteExce
         reply.recycle();
         return res;
     }
+    public IBinder getActivityForTask(int task, boolean onlyRoot) throws RemoteException
+    {
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        data.writeInterfaceToken(IActivityManager.descriptor);
+        data.writeInt(task);
+        data.writeInt(onlyRoot ? 1 : 0);
+        mRemote.transact(GET_ACTIVITY_FOR_TASK_TRANSACTION, data, reply, 0);
+        reply.readException();
+        IBinder res = reply.readStrongBinder();
+        data.recycle();
+        reply.recycle();
+        return res;
+    }
     public void reportThumbnail(IBinder token,
                                 Bitmap thumbnail, CharSequence description) throws RemoteException
     {
diff --git a/core/java/android/app/IActivityManager.java b/core/java/android/app/IActivityManager.java
index 6477f39..958c75b 100644
--- a/core/java/android/app/IActivityManager.java
+++ b/core/java/android/app/IActivityManager.java
@@ -126,6 +126,7 @@ public int createStack(int taskId, int relativeStackBoxId, int position, float w
     public StackBoxInfo getStackBoxInfo(int stackBoxId) throws RemoteException;
     public void setFocusedStack(int stackId) throws RemoteException;
     public int getTaskForActivity(IBinder token, boolean onlyRoot) throws RemoteException;
+    public IBinder getActivityForTask(int task, boolean onlyRoot) throws RemoteException;
     /* oneway */
     public void reportThumbnail(IBinder token,
             Bitmap thumbnail, CharSequence description) throws RemoteException;
@@ -696,4 +697,6 @@ private WaitResult(Parcel source) {
     int GET_PERSISTED_URI_PERMISSIONS_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+181;
     int APP_NOT_RESPONDING_VIA_PROVIDER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+182;
     int GET_CALLING_PACKAGE_FOR_BROADCAST_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+183;
+    /* SPLIT VIEW */
+    int GET_ACTIVITY_FOR_TASK_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+200;
 }
diff --git a/core/java/android/content/Intent.java b/core/java/android/content/Intent.java
index 6dd919e..13db09a 100644
--- a/core/java/android/content/Intent.java
+++ b/core/java/android/content/Intent.java
@@ -3667,6 +3667,19 @@ public static Intent createChooser(Intent target, CharSequence title) {
      */
     public static final int FLAG_ACTIVITY_TASK_ON_HOME = 0X00004000;
     /**
+     * If set, this intent will always match start up as a floating window
+     * in mutil window scenarios.
+     */
+    public static final int FLAG_FLOATING_WINDOW = 0x00002000;
+
+     /**
+	 * set in an Intent passed to {@link Context#startActivity Context.startActivity()},
+     * this flag will cause a newly launching task to be resized according to the split
+     * view metrics, making it running alongside another app.
+     */
+    public static final int FLAG_ACTIVITY_SPLIT_VIEW = 0x00002000;
+
+    /**
      * If set, when sending a broadcast only registered receivers will be
      * called -- no BroadcastReceiver components will be launched.
      */
diff --git a/core/java/android/inputmethodservice/InputMethodService.java b/core/java/android/inputmethodservice/InputMethodService.java
index f1ac2ad..d9b617b 100644
--- a/core/java/android/inputmethodservice/InputMethodService.java
+++ b/core/java/android/inputmethodservice/InputMethodService.java
@@ -31,8 +31,11 @@
 import android.graphics.Region;
 import android.os.Bundle;
 import android.os.Handler;
+import android.os.UserHandle;
 import android.os.IBinder;
+import android.os.RemoteException;
 import android.os.ResultReceiver;
+import android.os.ServiceManager;
 import android.os.SystemClock;
 import android.provider.Settings;
 import android.text.InputType;
@@ -70,6 +73,8 @@
 import android.widget.FrameLayout;
 import android.widget.LinearLayout;
 
+import com.android.internal.statusbar.IStatusBarService;
+
 import com.android.internal.util.amra.AwesomeAnimationHelper;
 
 import java.io.FileDescriptor;
@@ -326,8 +331,13 @@
     int mStatusIcon;
     int mBackDisposition;
 
+
+    boolean mForcedAutoRotate;
     Handler mHandler;
 
+    private IStatusBarService mStatusBarService;
+    private Object mServiceAquireLock = new Object();
+
     private Window mWindowIme;
     private int mAnimationDuration;
     private int mAnimationEnterIndex;
@@ -453,6 +463,7 @@ public void unbindInput() {
             if (DEBUG) Log.v(TAG, "unbindInput(): binding=" + mInputBinding
                     + " ic=" + mInputConnection);
             onUnbindInput();
+	    mInputStarted = false;
             mInputBinding = null;
             mInputConnection = null;
         }
@@ -792,6 +803,8 @@ void initViews() {
         mCandidatesVisibility = getCandidatesHiddenVisibility();
         mCandidatesFrame.setVisibility(mCandidatesVisibility);
         mInputFrame.setVisibility(View.GONE);
+
+	mHandler = new Handler();
     }
 
     @Override
@@ -959,7 +972,16 @@ public EditorInfo getCurrentInputEditorInfo() {
      * is currently running in fullscreen mode.
      */
     public void updateFullscreenMode() {
-        boolean isFullscreen = mShowInputRequested && onEvaluateFullscreenMode();
+        boolean fullScreenOverride = Settings.System.getIntForUser(getContentResolver(),
+                Settings.System.DISABLE_FULLSCREEN_KEYBOARD, 0,
+                UserHandle.USER_CURRENT_OR_SELF) != 0;
+        int mHaloEnabled = (Settings.System.getInt(getContentResolver(), Settings.System.HALO_ENABLED, 0));
+        boolean isFullscreen;
+        if (fullScreenOverride) {
+            isFullscreen = false;
+        } else {
+            isFullscreen = (mHaloEnabled != 1) ? (onEvaluateFullscreenMode() || onEvaluateSplitView()) : mShowInputRequested && onEvaluateFullscreenMode();
+        }
         boolean changed = mLastShowInputRequested != mShowInputRequested;
         if (mIsFullscreen != isFullscreen || !mFullscreenApplied) {
             changed = true;
@@ -1055,6 +1077,21 @@ public boolean onEvaluateFullscreenMode() {
         }
         return true;
     }
+    
+    public boolean onEvaluateSplitView() {
+        if (mCandidatesFrame.getChildCount() > 0) {
+            Context candidateContext = mCandidatesFrame.getChildAt(0).getContext();
+            if (candidateContext instanceof Activity) {
+                return ((Activity) candidateContext).isSplitView();
+            } else {
+                Log.e("XPLOD", "NOT ACTIVITY");
+                return false;
+            }
+        } else {
+            Log.e("XPLOD", "NO CHILD");
+            return false;
+        }
+    }
 
     /**
      * Controls the visibility of the extracted text area.  This only applies
@@ -2313,6 +2350,16 @@ public boolean onExtractTextContextMenuItem(int id) {
         return true;
     }
 
+    IStatusBarService getStatusBarService() {
+        synchronized (mServiceAquireLock) {
+            if (mStatusBarService == null) {
+                mStatusBarService = IStatusBarService.Stub.asInterface(
+                        ServiceManager.getService("statusbar"));
+            }
+            return mStatusBarService;
+        }
+    }
+
     /**
      * Return text that can be used as a button label for the given
      * {@link EditorInfo#imeOptions EditorInfo.imeOptions}.  Returns null
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 17d873e..0036551 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -3622,6 +3622,12 @@ public static void setShowGTalkServiceStatusForUser(ContentResolver cr, boolean
         */
         public static final String EXPANDED_RING_MODE = "expanded_ring_mode";
 
+       /**
+         * HALO enabled, should default to 0 (HALO is disabled)
+         * @hide
+         */
+        public static final String HALO_ENABLED = "halo_enabled";
+
         /**
         * Notification Power Widget - Custom Torch Mode
         * @hide
@@ -5271,6 +5277,67 @@ public static void setShowGTalkServiceStatusForUser(ContentResolver cr, boolean
         public static final String RECENT_PANEL_SCALE_FACTOR = "recent_panel_scale_factor";
 
         /**
+         * HALO, should default to 0 (no, do not show)
+         * @hide
+         */
+        public static final String HALO_ACTIVE = "halo_active";
+
+        /**
+         * HALO reversed?, should default to 1 (yes, reverse)
+         * @hide
+         */
+        public static final String HALO_REVERSED = "halo_reversed";
+
+        /**
+         * HALO hide?, should default to 0 (no, do not hide)
+         * @hide
+         */
+        public static final String HALO_HIDE = "halo_hide";
+
+        /**
+         * HALO pause activities?, defaults to 0 (no, do not pause) on devices which isLargeRAM() == true
+         * otherwise it defaults to 1 (yes, do pause)
+         * @hide
+         */
+        public static final String HALO_PAUSE = "halo_pause";
+
+        /**
+         * HALO size fraction, default is 1.0f (normal)
+         * @hide
+         */
+        public static final String HALO_SIZE = "halo_size";
+
+        /**
+         * HALO ninja?, should default to 0 (no, do not disappear when empty)
+         * @hide
+         */
+        public static final String HALO_NINJA = "halo_ninja";
+
+        /**
+         * HALO message box?, should default to 1 (yes, show message box on incoming notification)
+         * @hide
+         */
+        public static final String HALO_MSGBOX = "halo_msgbox";
+
+        /**
+         * HALO notificatoin count?, should default to 4 (both)
+         * @hide
+         */
+        public static final String HALO_NOTIFY_COUNT = "halo_notify_count";
+
+        /**
+         * HALO message box animation?, should default to 2 (flip animation)
+         * @hide
+         */
+        public static final String HALO_MSGBOX_ANIMATION = "halo_msgbox_animation";
+
+        /**
+         * HALO unlock ping?, should default to 0 (no, do not ping on unlock)
+         * @hide
+         */
+        public static final String HALO_UNLOCK_PING = "halo_unlock_ping";
+
+        /**
          * Settings to backup. This is here so that it's in the same place as the settings
          * keys and easy to update.
          *
diff --git a/core/java/android/view/IWindowManager.aidl b/core/java/android/view/IWindowManager.aidl
index 67b2544..0a791c2 100644
--- a/core/java/android/view/IWindowManager.aidl
+++ b/core/java/android/view/IWindowManager.aidl
@@ -316,4 +316,14 @@ interface IWindowManager
      * @hide
      */
     void toggleStatusBar();
+
+    /** SPLIT VIEW **/
+    boolean isTaskSplitView(int taskId);
+    void setTaskSplitView(int taskId, boolean split);
+    void setTaskChildSplit(IBinder token, boolean split);
+    Rect getSplitViewRect(int taskId, boolean resetLocation);
+    void notifyActivityTouched(IBinder token, boolean force);
+    void setSplitViewRect(int l, int t, int r, int b);
+
+    /** SPLIT VIEW END **/
 }
diff --git a/packages/SystemUI/res/menu/recent_popup_menu.xml b/packages/SystemUI/res/menu/recent_popup_menu.xml
index 9b6eb87..5f9a56a 100644
--- a/packages/SystemUI/res/menu/recent_popup_menu.xml
+++ b/packages/SystemUI/res/menu/recent_popup_menu.xml
@@ -18,6 +18,7 @@
 */
 -->
 <menu xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:id="@+id/recent_add_split_view" android:title="@string/status_bar_recent_add_to_split_view" />
     <item android:id="@+id/recent_remove_item" android:title="@string/status_bar_recent_remove_item_title" />
     <item android:id="@+id/recent_inspect_item" android:title="@string/status_bar_recent_inspect_item_title" />
     <item android:id="@+id/recent_force_stop" android:title="@string/advanced_dev_option_force_stop" />
diff --git a/packages/SystemUI/res/values-zh-rCN/mk_strings.xml b/packages/SystemUI/res/values-zh-rCN/mk_strings.xml
new file mode 100644
index 0000000..a51b0de
--- /dev/null
+++ b/packages/SystemUI/res/values-zh-rCN/mk_strings.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2013 The MoKee OpenSource Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+    <!-- Title shown in recents popup for adding an application to the split view -->
+    <string name="status_bar_recent_add_to_split_view">添加到拆分视图</string>
+
+</resources>
diff --git a/packages/SystemUI/res/values/mk_strings.xml b/packages/SystemUI/res/values/mk_strings.xml
new file mode 100644
index 0000000..35ccb50
--- /dev/null
+++ b/packages/SystemUI/res/values/mk_strings.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2013 The MoKee OpenSource Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+    <!-- Title shown in recents popup for adding an application to the split view -->
+    <string name="status_bar_recent_add_to_split_view">Add to Split View</string>
+
+</resources>
diff --git a/packages/SystemUI/src/com/android/systemui/recent/RecentsActivity.java b/packages/SystemUI/src/com/android/systemui/recent/RecentsActivity.java
index a109151..b012d07 100644
--- a/packages/SystemUI/src/com/android/systemui/recent/RecentsActivity.java
+++ b/packages/SystemUI/src/com/android/systemui/recent/RecentsActivity.java
@@ -177,6 +177,13 @@ public void dismissAndGoBack() {
         finish();
     }
 
+    public void dismissAndDoNothing() {
+        if (mRecentsPanel != null) {
+            mRecentsPanel.show(false);
+        }
+        finish();
+    }
+
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         getWindow().setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION,
diff --git a/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java b/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
index fa90cfe..78326a5 100644
--- a/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
+++ b/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
@@ -27,7 +27,9 @@
 import android.content.ActivityNotFoundException;
 import android.content.ContentResolver;
 import android.content.Context;
+import android.content.ComponentName;
 import android.content.Intent;
+import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.IPackageDataObserver;
 import android.content.pm.PackageManager;
@@ -39,6 +41,8 @@
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Matrix;
+import android.graphics.Point;
+import android.graphics.Rect;
 import android.graphics.Shader.TileMode;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
@@ -52,11 +56,15 @@
 import android.util.AttributeSet;
 import android.util.Log;
 import android.view.Gravity;
+import android.view.Display;
+import android.view.IWindowManager;
 import android.view.LayoutInflater;
 import android.view.MenuItem;
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewGroup;
+import android.view.WindowManager;
+import android.view.WindowManagerGlobal;
 import android.view.ViewPropertyAnimator;
 import android.view.ViewRootImpl;
 import android.view.accessibility.AccessibilityEvent;
@@ -65,6 +73,7 @@
 import android.widget.AdapterView;
 import android.widget.AdapterView.OnItemClickListener;
 import android.widget.BaseAdapter;
+import android.widget.FrameLayout;
 import android.widget.ImageView;
 import android.widget.ImageView.ScaleType;
 import android.widget.PopupMenu;
@@ -80,6 +89,10 @@
 import com.android.internal.util.MemInfoReader;
 
 import java.util.ArrayList;
+import java.util.List;
+import java.io.BufferedReader;
+import java.io.FileReader;
+import java.io.IOException;
 
 public class RecentsPanelView extends RelativeLayout implements OnItemClickListener,
         RecentsCallback, StatusBarPanel, Animator.AnimatorListener {
@@ -111,6 +124,10 @@
 
     private ImageView mClearAllRecents;
 
+    private int mDragPositionX;
+    private int mDragPositionY;
+    private ImageView mClearRecents;
+
     private boolean ramBarEnabled;
     private boolean ramBarIncludeCached;
 
@@ -269,8 +286,19 @@ public View getView(int position, View convertView, ViewGroup parent) {
                 }
             }
 
+	    int mHaloEnabled = (Settings.System.getInt(mContext.getContentResolver(), Settings.System.HALO_ENABLED, 0));
+
             holder.thumbnailView.setTag(td);
             holder.thumbnailView.setOnLongClickListener(new OnLongClickDelegate(convertView));
+
+	    if(mHaloEnabled != 1){
+		    holder.thumbnailView.setOnTouchListener(new OnTouchListener() {
+		        @Override
+		        public boolean onTouch(View v, MotionEvent m) {
+		            return handleThumbnailTouch(m, holder.thumbnailView);
+		        }
+		    });
+	    }
             holder.taskDescription = td;
             return convertView;
         }
@@ -406,6 +434,57 @@ private void showImpl(boolean show) {
         }
     }
 
+    private boolean handleThumbnailTouch(MotionEvent m, View thumb) {
+        // If we have two touches, let user snap on top or bottom
+        int pointerCount = m.getPointerCount();
+        if (pointerCount == 2) {
+            int action = m.getActionMasked();
+            int currX = (int) m.getX(1);
+            int currY = (int) m.getY(1);
+
+            switch (action) {
+                case MotionEvent.ACTION_DOWN:
+                case MotionEvent.ACTION_POINTER_DOWN:
+                    mDragPositionX = currX;
+                    mDragPositionY = currY;
+                    break;
+
+                case MotionEvent.ACTION_UP:
+                    handleThumbnailDragRelease(thumb);
+                    break;
+
+                case MotionEvent.ACTION_MOVE:
+                    int diffX = currX - mDragPositionX;
+                    int diffY = currY - mDragPositionY;
+                    thumb.setTranslationX(thumb.getTranslationX() + diffX);
+                    thumb.setTranslationY(thumb.getTranslationY() + diffY);
+                    mDragPositionX = currX;
+                    mDragPositionY = currY;
+                    break;
+            }
+            return true;
+        } else {
+            mDragPositionX = 0;
+            mDragPositionY = 0;
+            return false;
+        }
+    }
+
+    private void handleThumbnailDragRelease(View view) {
+        ViewHolder holder = (ViewHolder) view.getTag();
+        WindowManager wm = (WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE);
+        Display display = wm.getDefaultDisplay();
+        Point size = new Point();
+        display.getSize(size);
+        int width = size.x;
+        int height = size.y;
+        if (mDragPositionY < height/2) {
+            openInSplitView(holder, 0);
+        } else {
+            openInSplitView(holder, 1);
+        }
+    }
+
     @Override
     protected void onAttachedToWindow () {
         super.onAttachedToWindow();
@@ -453,6 +532,10 @@ public void dismissAndGoBack() {
         ((RecentsActivity) mContext).dismissAndGoBack();
     }
 
+    public void dismissAndDoNothing() {
+        ((RecentsActivity) mContext).dismissAndDoNothing();
+    }
+
     public void onAnimationCancel(Animator animation) {
     }
 
@@ -746,6 +829,8 @@ public void handleOnClick(View view) {
         ViewHolder holder = (ViewHolder) view.getTag();
         TaskDescription ad = holder.taskDescription;
         final Context context = view.getContext();
+        final ActivityManager am = (ActivityManager)
+                context.getSystemService(Context.ACTIVITY_SERVICE);
 
         Bitmap bm = null;
         boolean usingDrawingCache = true;
@@ -768,8 +853,23 @@ public void handleOnClick(View view) {
         show(false);
         if (ad.taskId >= 0) {
             // This is an active task; it should just go to the foreground.
-            mAm.moveTaskToFront(ad.taskId, ActivityManager.MOVE_TASK_WITH_HOME,
+
+	    int mHaloEnabled = (Settings.System.getInt(mContext.getContentResolver(), Settings.System.HALO_ENABLED, 0));
+
+            // If that task was split viewed, a normal press wil resume it to
+            // normal fullscreen view
+	    if(mHaloEnabled != 1){
+		    IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+		    try {
+		        if (DEBUG) Log.v(TAG, "Restoring window full screen after split, because of normal tap");
+		        wm.setTaskSplitView(ad.taskId, false);
+		    } catch (RemoteException e) {
+		        Log.e(TAG, "Could not setTaskSplitView to fullscreen", e);
+		    }
+	    }
+            am.moveTaskToFront(ad.taskId, ActivityManager.MOVE_TASK_WITH_HOME,
                     opts);
+	    
         } else {
             Intent intent = ad.intent;
             intent.addFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY
@@ -841,6 +941,89 @@ public boolean onInterceptTouchEvent(MotionEvent ev) {
         }
     }
 
+    /**
+	* Opens the task linked in the ViewHolder in split view mode.
+	* @param holder ViewHolder of a task thumbnail
+	* @param location Where to put the split app (-1 for auto, 0 for top, 1 for bottom (the
+	* reference is a phone in portrait))
+    */
+    public void openInSplitView(ViewHolder holder, int location) {
+        if (holder != null) {
+            final Context context = holder.thumbnailView.getContext();
+            final ActivityManager am = (ActivityManager)
+                context.getSystemService(Context.ACTIVITY_SERVICE);
+            final IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+
+            TaskDescription ad = holder.taskDescription;
+
+            show(false);
+            dismissAndDoNothing();
+
+            // If we weren't on the homescreen, resize the previous activity (if not already split)
+            final List<ActivityManager.RecentTaskInfo> recentTasks =
+                am.getRecentTasks(20, ActivityManager.RECENT_IGNORE_UNAVAILABLE);
+
+            if (recentTasks != null && recentTasks.size() > 0) {
+                final PackageManager pm = mContext.getPackageManager();
+                ActivityInfo homeInfo = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME)
+                        .resolveActivityInfo(pm, 0);
+                int taskInt = 0;
+                ActivityManager.RecentTaskInfo taskInfo = recentTasks.get(1);
+                Log.e("XPLOD", "Resizing previous activity " + taskInfo.baseIntent);
+                Intent intent = new Intent(taskInfo.baseIntent);
+                if (taskInfo.origActivity != null) {
+                    intent.setComponent(taskInfo.origActivity);
+                }
+
+                ComponentName component = intent.getComponent();
+
+                if (homeInfo == null
+                    || !homeInfo.packageName.equals(component.getPackageName())
+                    || !homeInfo.name.equals(component.getClassName())) {
+                    Log.e("XPLOD", "not home intent, splitting");
+                    // This is not the home activity, so split it
+                    try {
+                        wm.setTaskSplitView(taskInfo.persistentId, true);
+                    } catch (RemoteException e) {
+                        Log.e(TAG, "Could not set previous task to split view", e);
+                    }
+
+                    // We move this to front first, then our activity, so it updates
+                    am.moveTaskToFront(taskInfo.persistentId, 0, null);
+                }
+            }
+
+            if (ad.taskId >= 0) {
+                // The task is already launched. The Activity will pull its split
+                // information from WindowManagerService once it resumes, so we
+                // set its state here.
+                try {
+                    wm.setTaskSplitView(ad.taskId, true);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Could not setTaskSplitView", e);
+                }
+                am.moveTaskToFront(ad.taskId, 0, null);
+            } else {
+                // The app has been killed (we have no taskId for it), so we start
+                // a new one with the SPLIT_VIEW flag
+                Intent intent = ad.intent;
+                intent.addFlags(Intent.FLAG_ACTIVITY_SPLIT_VIEW
+                    | Intent.FLAG_ACTIVITY_NEW_TASK);
+
+                if (DEBUG) Log.v(TAG, "Starting split view activity " + intent);
+
+                try {
+                    context.startActivityAsUser(intent, null,
+                            new UserHandle(UserHandle.USER_CURRENT));
+                } catch (SecurityException e) {
+                    Log.e(TAG, "Recents does not have the permission to launch " + intent, e);
+                }
+            }
+        } else {
+            throw new IllegalStateException("Oops, no tag on view to split!");
+        }
+    }
+
     public void handleLongPress(
             final View selectedView, final View anchorView, final View thumbnailView) {
         thumbnailView.setSelected(true);
@@ -879,6 +1062,9 @@ public void handleLongPress(
         }
         popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
             public boolean onMenuItemClick(MenuItem item) {
+
+		int mHaloEnabled = (Settings.System.getInt(mContext.getContentResolver(), Settings.System.HALO_ENABLED, 0));
+
                 if (item.getItemId() == R.id.recent_remove_item) {
                     ((ViewGroup) mRecentsContainer).removeViewInLayout(selectedView);
                 } else if (item.getItemId() == R.id.recent_inspect_item) {
@@ -913,6 +1099,11 @@ public boolean onMenuItemClick(MenuItem item) {
                     } else {
                         throw new IllegalStateException("Oops, no tag on view " + selectedView);
                     }
+                } else if (item.getItemId() == R.id.recent_add_split_view && mHaloEnabled != 1) {
+                    // Either start a new activity in split view, or move the current task
+                    // to front, but resized
+                    ViewHolder holder = (ViewHolder)selectedView.getTag();
+                    openInSplitView(holder, -1);
                 } else {
                     return false;
                 }
diff --git a/policy/src/com/android/internal/policy/impl/PhoneWindow.java b/policy/src/com/android/internal/policy/impl/PhoneWindow.java
index 050c9f2..a0439b2 100644
--- a/policy/src/com/android/internal/policy/impl/PhoneWindow.java
+++ b/policy/src/com/android/internal/policy/impl/PhoneWindow.java
@@ -39,6 +39,9 @@
 import com.android.internal.widget.ActionBarOverlayLayout;
 import com.android.internal.widget.ActionBarView;
 
+import android.app.ActivityManager;
+import android.app.ActivityManager.RunningAppProcessInfo;
+import android.app.Activity;
 import android.app.KeyguardManager;
 import android.content.ComponentName;
 import android.content.ContentResolver;
diff --git a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
index 874d8cf..0553a59 100644
--- a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
+++ b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
@@ -3821,6 +3821,10 @@ private void applyStableConstraints(int sysui, WindowManager.LayoutParams attrs,
         }
     }
 
+    public Rect getContentRect() {
+        return new Rect(mContentLeft, mContentTop, mContentRight, mContentBottom);
+    }
+
     /** {@inheritDoc} */
     @Override
     public void layoutWindowLw(WindowState win, WindowManager.LayoutParams attrs,
diff --git a/services/java/com/android/server/am/ActivityManagerService.java b/services/java/com/android/server/am/ActivityManagerService.java
index a2886ec..2e3d960 100644
--- a/services/java/com/android/server/am/ActivityManagerService.java
+++ b/services/java/com/android/server/am/ActivityManagerService.java
@@ -7396,6 +7396,22 @@ public int getTaskForActivity(IBinder token, boolean onlyRoot) {
         }
     }
 
+    public IBinder getActivityForTask(int task, boolean onlyRoot) {
+        final ActivityStack mainStack = mStackSupervisor.getFocusedStack();
+        synchronized(this) {
+            ArrayList<ActivityStack> stacks = mStackSupervisor.getStacks();
+            for (ActivityStack stack : stacks) {
+                TaskRecord r = stack.taskForIdLocked(task);
+                if (r != null && r.getTopActivity() != null) {
+                    return r.getTopActivity().appToken;
+                } else {
+                    return null;
+                }
+            }
+        }
+        return null;
+    }
+
     // =========================================================
     // THUMBNAILS
     // =========================================================
@@ -14287,12 +14303,37 @@ boolean updateConfigurationLocked(Configuration values,
             starting = mainStack.topRunningActivityLocked(null);
         }
 
-        if (starting != null) {
-            kept = mainStack.ensureActivityConfigurationLocked(starting, changes);
-            // And we need to make sure at this point that all other activities
-            // are made visible with the correct configuration.
-            mStackSupervisor.ensureActivitiesVisibleLocked(starting, changes);
-        }
+	if (starting != null) {
+	    kept = mainStack.ensureActivityConfigurationLocked(starting, changes);
+	    // And we need to make sure at this point that all other activities
+	    // are made visible with the correct configuration.
+	    mStackSupervisor.ensureActivitiesVisibleLocked(starting, changes);
+	    
+	    /*
+	    int mHaloEnabled = (Settings.System.getInt(mContext.getContentResolver(), Settings.System.HALO_ENABLED, 0));
+
+	    if(mHaloEnabled != 1){
+		    if (mWindowManager.isTaskSplitView(starting.task.taskId)) {
+			Log.e("XPLOD", "Split view restoring task " + starting.task.taskId + " -- " + mIgnoreSplitViewUpdate.size());
+			ActivityRecord second = mainStack.topRunningActivityLocked(starting);
+			if (mWindowManager.isTaskSplitView(second.task.taskId)) {
+			    Log.e("XPLOD", "Split view restoring also task " + second.task.taskId);
+			    kept = kept && mainStack.ensureActivityConfigurationLocked(second, changes);
+			    mStackSupervisor.ensureActivitiesVisibleLocked(second, changes);
+			    if (mIgnoreSplitViewUpdate.contains(starting.task.taskId)) {
+				Log.e("XPLOD", "Task "+ starting.task.taskId + " resuming ignored");
+				mIgnoreSplitViewUpdate.removeAll(Collections.singleton((Integer) starting.task.taskId));
+			    } else {
+				moveTaskToFront(second.task.taskId, 0, null);
+				mIgnoreSplitViewUpdate.add(starting.task.taskId);
+				mIgnoreSplitViewUpdate.add(second.task.taskId);
+				mStackSupervisor.resumeTopActivitiesLocked();
+				moveTaskToFront(starting.task.taskId, 0, null);
+			    }
+			}
+		    }
+	    }*/
+	}
 
         if (values != null && mWindowManager != null) {
             mWindowManager.setNewConfiguration(mConfiguration);
@@ -14301,6 +14342,8 @@ boolean updateConfigurationLocked(Configuration values,
         return kept;
     }
 
+    private ArrayList<Integer> mIgnoreSplitViewUpdate = new ArrayList<Integer>();
+
     /**
      * Decide based on the configuration whether we should shouw the ANR,
      * crash, etc dialogs.  The idea is that if there is no affordnace to
@@ -15525,10 +15568,32 @@ private final boolean updateOomAdjLocked(ProcessRecord app, int cachedAdj,
                 reportingProcessState, now);
     }
 
+    private ArrayList<Integer> mIgnoreSplitViewUpdateResume = new ArrayList<Integer>();
+
     private final ActivityRecord resumedAppLocked() {
-        return mStackSupervisor.resumedAppLocked();
+        final ActivityRecord starting = mStackSupervisor.resumedAppLocked();
+
+        final long origId = Binder.clearCallingIdentity();
+
+        if (mSecondTaskToResume >= 0) {
+            moveTaskToFront(mSecondTaskToResume, 0, null);
+            mStackSupervisor.resumeTopActivitiesLocked();
+            mStackSupervisor.ensureActivitiesVisibleLocked(null, 0);
+            mIgnoreSplitViewUpdateResume.add(mSecondTaskToResume);
+
+            if (mIgnoreSplitViewUpdateResume.contains((Integer) starting.task.taskId)) {
+                mSecondTaskToResume = -1;
+            } else {
+                mSecondTaskToResume = starting.task.taskId;
+            }
+        }
+
+        Binder.restoreCallingIdentity(origId);
+
+        return starting;
     }
 
+
     final boolean updateOomAdjLocked(ProcessRecord app) {
         return updateOomAdjLocked(app, false);
     }
@@ -16776,4 +16841,34 @@ ActivityInfo getActivityInfoForUser(ActivityInfo aInfo, int userId) {
         info.applicationInfo = getAppInfoForUser(info.applicationInfo, userId);
         return info;
     }
+
+    private int mSecondTaskToResume = -1;
+
+    public void notifySplitViewLayoutChanged() {
+        final long origId = Binder.clearCallingIdentity();
+
+        ActivityRecord starting = getFocusedStack().topRunningActivityLocked(null);
+
+        if (mWindowManager != null && starting != null &&
+                mWindowManager.isTaskSplitView(starting.task.taskId)) {
+            Log.e("XPLOD", "[rAL] The current resumed task " + starting.task.taskId + " is split. Checking second");
+
+            // This task was split, we resume the second task if this task wasn't already a resumed task
+            if (mIgnoreSplitViewUpdateResume.contains(starting.task.taskId)) {
+                Log.e("XPLOD", "[rAL] This task (" + starting.task.taskId + ") was called from a split-initiated resume. Ignoring.");
+                mIgnoreSplitViewUpdateResume.remove((Integer) starting.task.taskId);
+            } else {
+                ActivityRecord second = getFocusedStack().topRunningActivityLocked(starting);
+
+                // Is that second task split as well?
+                if (second != null && mWindowManager.isTaskSplitView(second.task.taskId)) {
+                    // Don't restore me again
+                    Log.e("XPLOD", "[rAL] There is a second task that I should be ignoring next: " + second.task.taskId);
+                    mSecondTaskToResume = second.task.taskId;
+                }
+            }
+        }
+
+        Binder.restoreCallingIdentity(origId);
+    }
 }
diff --git a/services/java/com/android/server/am/ActivityStack.java b/services/java/com/android/server/am/ActivityStack.java
index 74e787d..b0e95a4 100755
--- a/services/java/com/android/server/am/ActivityStack.java
+++ b/services/java/com/android/server/am/ActivityStack.java
@@ -37,6 +37,7 @@
 import static com.android.server.am.ActivityStackSupervisor.HOME_STACK_ID;
 
 import com.android.internal.os.BatteryStatsImpl;
+import com.android.server.AttributeCache;
 import com.android.internal.util.Objects;
 import com.android.server.Watchdog;
 import com.android.server.am.ActivityManagerService.ItemMatcher;
@@ -75,9 +76,14 @@
 import android.os.Trace;
 import android.os.UserHandle;
 import android.text.TextUtils;
+import android.provider.Settings;
 import android.util.EventLog;
+import android.util.Log;
 import android.util.Slog;
+import android.view.ContextThemeWrapper;
 import android.view.Display;
+import android.view.IWindowManager;
+import android.view.WindowManagerGlobal;
 import com.android.internal.app.ActivityTrigger;
 
 import java.io.FileDescriptor;
@@ -1153,7 +1159,19 @@ final boolean ensureActivitiesVisibleLocked(ActivityRecord top, ActivityRecord s
                     // Aggregate current change flags.
                     configChanges |= r.configChangeFlags;
 
-                    if (r.fullscreen) {
+		    int mHaloEnabled = (Settings.System.getInt(mContext.getContentResolver(), Settings.System.HALO_ENABLED, 0));
+                    boolean isSplitView = false;
+
+		    if(mHaloEnabled != 1){
+		            try {
+		                IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+		                isSplitView = wm.isTaskSplitView(r.task.taskId);
+		            } catch (RemoteException e) {
+		                Slog.e(TAG, "Cannot get split view status", e);
+		            }
+		    }
+
+                    if (r.fullscreen && !isSplitView) {
                         // At this point, nothing else needs to be shown
                         if (DEBUG_VISBILITY) Slog.v(TAG, "Fullscreen: at " + r);
                         behindFullscreen = true;
@@ -1261,6 +1279,7 @@ void notifyActivityDrawnLocked(ActivityRecord r) {
      * nothing happened.
      */
     final boolean resumeTopActivityLocked(ActivityRecord prev) {
+		Log.e("XPLOD", "Resume Top Activity Locked " + prev);
         return resumeTopActivityLocked(prev, null);
     }
 
diff --git a/services/java/com/android/server/wm/WindowManagerService.java b/services/java/com/android/server/wm/WindowManagerService.java
index 45f4452..8285011 100644
--- a/services/java/com/android/server/wm/WindowManagerService.java
+++ b/services/java/com/android/server/wm/WindowManagerService.java
@@ -47,6 +47,7 @@
 
 import android.Manifest;
 import android.app.ActivityManager.StackBoxInfo;
+import android.app.ActivityManager;
 import android.app.ActivityManagerNative;
 import android.app.IActivityManager;
 import android.app.StatusBarManager;
@@ -154,6 +155,7 @@
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.Map;
 import java.util.List;
 
 /** {@hide} */
@@ -811,6 +813,12 @@ public void onOpChanged(int op, String packageName) {
         // Add ourself to the Watchdog monitors.
         Watchdog.getInstance().addMonitor(this);
 
+        mSplitViewTasks = new int[2];
+        mNextSplitViewLocation = 0;
+        mIsTaskSplitted = new HashMap<Integer, Boolean>();
+        mTaskLocation = new HashMap<Integer, Integer>();
+        mIsTokenSplitted = new HashMap<IBinder, Boolean>();
+
         SurfaceControl.openTransaction();
         try {
             createWatermarkInTransaction();
@@ -9947,7 +9955,35 @@ private WindowState findFocusedWindowLocked(DisplayContent displayContent) {
 
             if (DEBUG_FOCUS_LIGHT) Slog.v(TAG, "findFocusedWindow: Found new focus @ " + i +
                         " = " + win);
-            return win;
+
+	    int mHaloEnabled = (Settings.System.getInt(mContext.getContentResolver(), Settings.System.HALO_ENABLED, 0));
+
+            if(mHaloEnabled != 1){
+		    // Dispatch to this window if it is wants key events.
+		    if (win.canReceiveKeys()) {
+		        if (mFocusedApp != null) {
+		            if (mIsTokenSplitted.containsKey(mFocusedApp.token) && mIsTokenSplitted.get(mFocusedApp.token)) {
+		                if ((mTaskTouched != null && mTaskTouched.equals(mFocusedApp.token)) || mTaskTouched == null) {
+		                    if (DEBUG_FOCUS) Slog.v(
+		                        TAG, "Found focus @ " + i + " = " + win);
+		                    return win;
+		                } else {
+		                    if (DEBUG_FOCUS || localLOGV) Slog.v(
+		                        TAG, "Task " + win + " is split, but not last touched");
+		                }
+		            } else {
+		                if (DEBUG_FOCUS) Slog.v(TAG, "Task " + win + " has no split token");
+		                return win;
+		            }
+		        } else {
+		            if (DEBUG_FOCUS) Slog.v(TAG, "Null thisApp");
+		            return win;
+		        }
+		    }	
+	    }else{
+		return win;
+	    }
+	    
         }
 
         if (DEBUG_FOCUS_LIGHT) Slog.v(TAG, "findFocusedWindow: No focusable windows.");
@@ -10964,8 +11000,187 @@ public void addSystemUIVisibilityFlag(int flag) {
     }
 
     /* @hide */
+
     @Override
     public int getSystemUIVisibility() {
         return mLastStatusBarVisibility;
     }
+
+    /** SPLIT VIEW **/
+    private int mSplitViewTasks[];
+    private int mNextSplitViewLocation;
+    private Map<Integer, Boolean> mIsTaskSplitted;
+    private Map<IBinder, Boolean> mIsTokenSplitted;
+    private Map<Integer, Integer> mTaskLocation;
+    private IBinder mTaskTouched;
+    private Rect mSplitViewRect = new Rect();
+
+    /**
+     * Returns whether or not the provided taskId is in split view mode
+     * or not. Remember that the taskId is shared between all activities
+     * of an app, thus children activities from the root one shares the
+     * same taskId.
+     *
+     * @param taskId The task id of the activity
+     * @return True if the task is in split view mode
+     */
+    public boolean isTaskSplitView(int taskId) {
+        if (mIsTaskSplitted.containsKey(taskId)) {
+            return mIsTaskSplitted.get(taskId);
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Sets whether or not a task should be in split view or not. The
+     * update only occurs when activities performs a resume or restart
+     * operation.
+     *
+     * @param taskId The task id of the activity
+     * @param split True to enable split mode, false otherwise
+     */
+    public void setTaskSplitView(int taskId, boolean split) {
+        mIsTaskSplitted.put(taskId, split);
+        try {
+            mIsTokenSplitted.put(mActivityManager.getActivityForTask(taskId, false), split);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Cannot retrieve activity token for task " + taskId, e);
+        }
+    }
+
+    /**
+     * Notifies the WindowManager that the provided token is split
+     * or not. This is useful because children activities don't share
+     * the same token, so Activity can notify the window token is split
+     * as well based on the taskId it reads during performRestart.
+     *
+     * @param token The activity token
+     * @param split True if the token should be split
+     */
+    public void setTaskChildSplit(IBinder token, boolean split) {
+        mIsTokenSplitted.put(token, split);
+    }
+
+    /**
+     * Notifies that the provided activity token has been touched, and
+     * sets the focus to that activity, and move it to the front so it
+     * gets updated properly.
+     *
+     * @param token The activity token
+     * @param force Set this to true to force the focus update even if the
+     *              application was already focused
+     */
+    public void notifyActivityTouched(IBinder token, boolean force) {
+        mTaskTouched = token;
+        synchronized(mWindowMap) {
+            boolean changed = false;
+            if (token != null) {
+                AppWindowToken newFocus = findAppWindowToken(token);
+                if (newFocus == null) {
+                    Slog.w(TAG, "Attempted to set focus to non-existing app token: " + token);
+                    return;
+                }
+                changed = mFocusedApp != newFocus;
+                mFocusedApp = newFocus;
+                if (changed || force) {
+                    if (DEBUG_FOCUS) Slog.v(TAG, "Changed app focus to " + token);
+                    mInputMonitor.setFocusedAppLw(newFocus);
+                }
+            }
+
+            if (changed || force) {
+                final long origId = Binder.clearCallingIdentity();
+                updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL, true);
+                mH.removeMessages(H.REPORT_FOCUS_CHANGE);
+                mH.sendEmptyMessage(H.REPORT_FOCUS_CHANGE);
+                Binder.restoreCallingIdentity(origId);
+            }
+        }
+
+        // We only move the activity to front if it's not already the focused app.
+        // Not doing so causes a huge lag when opening an app in split view, because
+        // it is moved to front while starting.
+        if (!force) {
+            final long origId = Binder.clearCallingIdentity();
+            try {
+                mActivityManager.moveTaskToFront(mActivityManager.getTaskForActivity(token, false), 0, null);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Cannot move the activity to front", e);
+            }
+            Binder.restoreCallingIdentity(origId);
+        }
+    }
+
+    public void setSplitViewRect(int l, int t, int r, int b) {
+        Log.e("XPLOD", "Set split view rect ("+l+","+t+","+r+","+b+")");
+        mSplitViewRect.left = l;
+        mSplitViewRect.top = t;
+        mSplitViewRect.right = r;
+        mSplitViewRect.bottom = b;
+    }
+
+    /**
+     * Computes and return the final window metrics for the provided
+     * taskId. It will automatically set the task to the split mode.
+     *
+     * @param taskId The id of the task
+     * @param resetLocation True to reset the location to the next available spot
+     * @return A rect of the final window metrics
+     */
+    public Rect getSplitViewRect(int taskId, boolean resetLocation) {
+		Log.e("XPLOD", "Debug Activity " + taskId + " asked for split view rect");
+        mSplitViewTasks[mNextSplitViewLocation] = taskId;
+        mIsTaskSplitted.put(taskId, true);
+
+        // TODO(multidisplay): For now, apply Configuration to main screen only.
+        final DisplayContent displayContent = getDefaultDisplayContentLocked();
+
+        // Use the effective "visual" dimensions based on current rotation
+        final boolean rotated = (mRotation == Surface.ROTATION_90
+                || mRotation == Surface.ROTATION_270);
+        final int realdw = rotated ?
+                displayContent.mBaseDisplayHeight : displayContent.mBaseDisplayWidth;
+        final int realdh = rotated ?
+                displayContent.mBaseDisplayWidth : displayContent.mBaseDisplayHeight;
+	final boolean nativeLandscape =
+                (displayContent.mBaseDisplayHeight < displayContent.mBaseDisplayWidth);
+
+        int dw = realdw;
+        int dh = realdh;
+
+
+        // Get application display metrics.
+        final int appWidth = /*((PhoneWindowManager) mPolicy).getContentRect().right - ((PhoneWindowManager) mPolicy).getContentRect().left;//*/ mPolicy.getNonDecorDisplayWidth(dw, dh, mRotation);
+        final int appHeight = /*((PhoneWindowManager) mPolicy).getContentRect().bottom - ((PhoneWindowManager) mPolicy).getContentRect().top;//*/mPolicy.getNonDecorDisplayHeight(dw, dh, mRotation);
+
+        int location = mNextSplitViewLocation;
+        if (mTaskLocation.containsKey(taskId)) {
+            location = mTaskLocation.get(taskId);
+        } else {
+            if (mNextSplitViewLocation == 0) {
+                mNextSplitViewLocation = 1;
+            } else {
+                mNextSplitViewLocation = 0;
+            }
+        }
+
+        mTaskLocation.put(taskId, location);
+
+        if (location == 0) {
+            if (nativeLandscape ^ rotated) {
+                return new Rect(0, 0, appWidth/2, appHeight);
+            } else {
+                return new Rect(0, 0, appWidth, appHeight/2);
+            }
+        } else {
+            if (nativeLandscape ^ rotated) {
+                return new Rect(appWidth/2, 0, appWidth, appHeight);
+            } else {
+                return new Rect(0, appHeight/2, appWidth, appHeight);
+            }
+        }
+
+    }
+    /** END SPLIT VIEW **/
 }
