***************
*** 81,98 ****
  
  import com.android.internal.R;
  import com.android.internal.notification.NotificationScorer;
  import com.android.internal.util.cm.QuietHoursUtils;
  import com.android.internal.util.cm.SpamFilter;
  import com.android.internal.util.cm.SpamFilter.SpamContract.NotificationTable;
  import com.android.internal.util.cm.SpamFilter.SpamContract.PackageTable;
- 
  import org.xmlpull.v1.XmlPullParser;
  import org.xmlpull.v1.XmlPullParserException;
  
  import java.io.File;
  import java.io.FileDescriptor;
  import java.io.FileInputStream;
  import java.io.FileNotFoundException;
  import java.io.IOException;
  import java.io.PrintWriter;
  import java.lang.reflect.Array;
--- 81,100 ----
  
  import com.android.internal.R;
  import com.android.internal.notification.NotificationScorer;
+ import com.android.internal.util.FastXmlSerializer;
  import com.android.internal.util.cm.QuietHoursUtils;
  import com.android.internal.util.cm.SpamFilter;
  import com.android.internal.util.cm.SpamFilter.SpamContract.NotificationTable;
  import com.android.internal.util.cm.SpamFilter.SpamContract.PackageTable;
  import org.xmlpull.v1.XmlPullParser;
  import org.xmlpull.v1.XmlPullParserException;
+ import org.xmlpull.v1.XmlSerializer;
  
  import java.io.File;
  import java.io.FileDescriptor;
  import java.io.FileInputStream;
  import java.io.FileNotFoundException;
+ import java.io.FileOutputStream;
  import java.io.IOException;
  import java.io.PrintWriter;
  import java.lang.reflect.Array;
***************
*** 118,123 ****
      private static final String TAG = "NotificationService";
      private static final boolean DBG = false;
  
      private static final int MAX_PACKAGE_NOTIFICATIONS = 50;
  
      // message codes
--- 120,127 ----
      private static final String TAG = "NotificationService";
      private static final boolean DBG = false;
  
+     private static final String SYSTEM_FOLDER = "/data/system";
+ 
      private static final int MAX_PACKAGE_NOTIFICATIONS = 50;
  
      // message codes
***************
*** 219,232 ****
      private HashSet<String> mEnabledListenerPackageNames = new HashSet<String>();
  
      // Notification control database. For now just contains disabled packages.
-     private AtomicFile mPolicyFile;
      private HashSet<String> mBlockedPackages = new HashSet<String>();
  
      private static final int DB_VERSION = 1;
  
      private static final String TAG_BODY = "notification-policy";
      private static final String ATTR_VERSION = "version";
  
      private static final String TAG_BLOCKED_PKGS = "blocked-packages";
      private static final String TAG_PACKAGE = "package";
      private static final String ATTR_NAME = "name";
--- 223,241 ----
      private HashSet<String> mEnabledListenerPackageNames = new HashSet<String>();
  
      // Notification control database. For now just contains disabled packages.
+     private AtomicFile mPolicyFile, mHaloPolicyFile;
      private HashSet<String> mBlockedPackages = new HashSet<String>();
+     private HashSet<String> mHaloBlacklist = new HashSet<String>();
+     private HashSet<String> mHaloWhitelist = new HashSet<String>();
+     private boolean mHaloPolicyisBlack = true;
  
      private static final int DB_VERSION = 1;
  
      private static final String TAG_BODY = "notification-policy";
      private static final String ATTR_VERSION = "version";
+     private static final String ATTR_HALO_POLICY_IS_BLACK = "policy_is_black";
  
+     private static final String TAG_ALLOWED_PKGS = "allowed-packages";
      private static final String TAG_BLOCKED_PKGS = "blocked-packages";
      private static final String TAG_PACKAGE = "package";
      private static final String ATTR_NAME = "name";
***************
*** 409,463 ****
  
      Archive mArchive = new Archive();
  
      private void loadBlockDb() {
          synchronized(mBlockedPackages) {
              if (mPolicyFile == null) {
-                 File dir = new File("/data/system");
-                 mPolicyFile = new AtomicFile(new File(dir, "notification_policy.xml"));
- 
                  mBlockedPackages.clear();
  
-                 FileInputStream infile = null;
-                 try {
-                     infile = mPolicyFile.openRead();
-                     final XmlPullParser parser = Xml.newPullParser();
-                     parser.setInput(infile, null);
- 
-                     int type;
-                     String tag;
-                     int version = DB_VERSION;
-                     while ((type = parser.next()) != END_DOCUMENT) {
-                         tag = parser.getName();
-                         if (type == START_TAG) {
-                             if (TAG_BODY.equals(tag)) {
-                                 version = Integer.parseInt(parser.getAttributeValue(null, ATTR_VERSION));
-                             } else if (TAG_BLOCKED_PKGS.equals(tag)) {
-                                 while ((type = parser.next()) != END_DOCUMENT) {
-                                     tag = parser.getName();
-                                     if (TAG_PACKAGE.equals(tag)) {
-                                         mBlockedPackages.add(parser.getAttributeValue(null, ATTR_NAME));
-                                     } else if (TAG_BLOCKED_PKGS.equals(tag) && type == END_TAG) {
-                                         break;
-                                     }
-                                 }
-                             }
                          }
-                     }
-                 } catch (FileNotFoundException e) {
-                     // No data yet
-                 } catch (IOException e) {
-                     Log.wtf(TAG, "Unable to read blocked notifications database", e);
-                 } catch (NumberFormatException e) {
-                     Log.wtf(TAG, "Unable to parse blocked notifications database", e);
-                 } catch (XmlPullParserException e) {
-                     Log.wtf(TAG, "Unable to parse blocked notifications database", e);
-                 } finally {
-                     IoUtils.closeQuietly(infile);
                  }
              }
          }
      }
  
      /**
       * Use this when you just want to know if notifications are OK for this package.
       */
--- 418,605 ----
  
      Archive mArchive = new Archive();
  
+     private int readPolicy(AtomicFile file, String lookUpTag, HashSet<String> db) {
+         return readPolicy(file, lookUpTag, db, null, 0);
+     }
+ 
+     private int readPolicy(AtomicFile file, String lookUpTag, HashSet<String> db, String resultTag, int defaultResult) {
+         int result = defaultResult;
+         FileInputStream infile = null;
+         try {
+             infile = file.openRead();
+             final XmlPullParser parser = Xml.newPullParser();
+             parser.setInput(infile, null);
+ 
+             int type;
+             String tag;
+             int version = DB_VERSION;
+             while ((type = parser.next()) != END_DOCUMENT) {
+                 tag = parser.getName();
+                 if (type == START_TAG) {
+                     if (TAG_BODY.equals(tag)) {
+                         version = Integer.parseInt(parser.getAttributeValue(null, ATTR_VERSION));
+                         if (resultTag != null) {
+                             String attribValue = parser.getAttributeValue(null, resultTag);
+                             result = Integer.parseInt((attribValue != null ? attribValue : "0"));
+                         }
+                     } else if (lookUpTag.equals(tag)) {
+                         while ((type = parser.next()) != END_DOCUMENT) {
+                             tag = parser.getName();
+                             if (TAG_PACKAGE.equals(tag)) {
+                                 db.add(parser.getAttributeValue(null, ATTR_NAME));
+                             } else if (lookUpTag.equals(tag) && type == END_TAG) {
+                                 break;
+                             }
+                         }
+                     }
+                 }
+             }
+         } catch (Exception e) {
+             // Unable to read
+         } finally {
+             IoUtils.closeQuietly(infile);
+         }
+         return result;
+     }
+ 
      private void loadBlockDb() {
          synchronized(mBlockedPackages) {
              if (mPolicyFile == null) {
+                 mPolicyFile = new AtomicFile(new File(SYSTEM_FOLDER, "notification_policy.xml"));
                  mBlockedPackages.clear();
+                 readPolicy(mPolicyFile, TAG_BLOCKED_PKGS, mBlockedPackages);
+             }
+         }
+     }
  
+     private synchronized void loadHaloBlockDb() {
+         if (mHaloPolicyFile == null) {
+             mHaloPolicyFile = new AtomicFile(new File(SYSTEM_FOLDER, "halo_policy.xml"));
+             mHaloBlacklist.clear();
+             mHaloPolicyisBlack = readPolicy(mHaloPolicyFile, TAG_BLOCKED_PKGS, mHaloBlacklist, ATTR_HALO_POLICY_IS_BLACK, 1) == 1;
+             mHaloWhitelist.clear();
+             readPolicy(mHaloPolicyFile, TAG_ALLOWED_PKGS, mHaloWhitelist);
+         }
+     }
+ 
+     private void writeBlockDb() {
+         synchronized(mBlockedPackages) {
+             FileOutputStream outfile = null;
+             try {
+                 outfile = mPolicyFile.startWrite();
+ 
+                 XmlSerializer out = new FastXmlSerializer();
+                 out.setOutput(outfile, "utf-8");
+ 
+                 out.startDocument(null, true);
+ 
+                 out.startTag(null, TAG_BODY); {
+                     out.attribute(null, ATTR_VERSION, String.valueOf(DB_VERSION));
+                     out.startTag(null, TAG_BLOCKED_PKGS); {
+                         // write all known network policies
+                         for (String pkg : mBlockedPackages) {
+                             out.startTag(null, TAG_PACKAGE); {
+                                 out.attribute(null, ATTR_NAME, pkg);
+                             } out.endTag(null, TAG_PACKAGE);
                          }
+                     } out.endTag(null, TAG_BLOCKED_PKGS);
+                 } out.endTag(null, TAG_BODY);
+ 
+                 out.endDocument();
+ 
+                 mPolicyFile.finishWrite(outfile);
+             } catch (IOException e) {
+                 if (outfile != null) {
+                     mPolicyFile.failWrite(outfile);
                  }
              }
          }
      }
  
+     private synchronized void writeHaloBlockDb() {
+         FileOutputStream outfile = null;
+         try {
+             outfile = mHaloPolicyFile.startWrite();
+ 
+             XmlSerializer out = new FastXmlSerializer();
+             out.setOutput(outfile, "utf-8");
+ 
+             out.startDocument(null, true);
+ 
+             out.startTag(null, TAG_BODY); {
+                 out.attribute(null, ATTR_VERSION, String.valueOf(DB_VERSION));
+                 out.attribute(null, ATTR_HALO_POLICY_IS_BLACK, (mHaloPolicyisBlack ? "1" : "0"));
+ 
+                     out.startTag(null, TAG_BLOCKED_PKGS); {
+                         for (String blockedPkg : mHaloBlacklist) {
+                             out.startTag(null, TAG_PACKAGE); {
+                                 out.attribute(null, ATTR_NAME, blockedPkg);
+                             } out.endTag(null, TAG_PACKAGE);
+                         }
+                     } out.endTag(null, TAG_BLOCKED_PKGS);
+                     out.startTag(null, TAG_ALLOWED_PKGS); {
+                         for (String allowedPkg : mHaloWhitelist) {
+                             out.startTag(null, TAG_PACKAGE); {
+                                 out.attribute(null, ATTR_NAME, allowedPkg);
+                             } out.endTag(null, TAG_PACKAGE);
+                         }
+                     } out.endTag(null, TAG_ALLOWED_PKGS);
+ 
+             } out.endTag(null, TAG_BODY);
+ 
+             out.endDocument();
+ 
+             mHaloPolicyFile.finishWrite(outfile);
+         } catch (IOException e) {
+             if (outfile != null) {
+                 mHaloPolicyFile.failWrite(outfile);
+             }
+         }
+     }
+ 
+     public void setHaloPolicyBlack(boolean state) {
+         mHaloPolicyisBlack = state;
+         writeHaloBlockDb();
+     }
+ 
+     public void setHaloStatus(String pkg, boolean status) {
+         if (mHaloPolicyisBlack) {
+             setHaloBlacklistStatus(pkg, status);
+         } else {
+             setHaloWhitelistStatus(pkg, status);
+         }
+     }
+ 
+     public void setHaloBlacklistStatus(String pkg, boolean status) {
+         if (status) {
+             mHaloBlacklist.add(pkg);
+         } else {
+             mHaloBlacklist.remove(pkg);
+         }
+         writeHaloBlockDb();
+     }
+ 
+     public void setHaloWhitelistStatus(String pkg, boolean status) {
+         if (status) {
+             mHaloWhitelist.add(pkg);
+         } else {
+             mHaloWhitelist.remove(pkg);
+         }
+         writeHaloBlockDb();
+     }
+ 
+     public boolean isHaloPolicyBlack() {
+         return mHaloPolicyisBlack;
+     }
+ 
+     public boolean isPackageAllowedForHalo(String pkg) {
+         if (mHaloPolicyisBlack) {
+             return !mHaloBlacklist.contains(pkg);
+         } else {
+             return mHaloWhitelist.contains(pkg);
+         }
+     }
+ 
      /**
       * Use this when you just want to know if notifications are OK for this package.
       */
***************
*** 656,662 ****
              final ComponentName component = info.component;
              final int oldUser = info.userid;
              Slog.v(TAG, "disabling notification listener for user " + oldUser + ": " + component);
-             unregisterListenerService(component, info.userid);
          }
  
          final int N = toAdd.size();
--- 799,806 ----
              final ComponentName component = info.component;
              final int oldUser = info.userid;
              Slog.v(TAG, "disabling notification listener for user " + oldUser + ": " + component);
+             // Do not un-register HALO, we un-register only when HALO is closed
+             if (!component.getPackageName().equals("HaloComponent")) unregisterListenerService(component, info.userid);
          }
  
          final int N = toAdd.size();
***************
*** 677,683 ****
      @Override
      public void registerListener(final INotificationListener listener,
              final ComponentName component, final int userid) {
-         checkCallerIsSystem();
  
          synchronized (mNotificationList) {
              try {
--- 821,827 ----
      @Override
      public void registerListener(final INotificationListener listener,
              final ComponentName component, final int userid) {
+         if (!component.getPackageName().equals("HaloComponent")) checkCallerIsSystem();
  
          synchronized (mNotificationList) {
              try {
***************
*** 1507,1513 ****
       * Read the old XML-based app block database and import those blockages into the AppOps system.
       */
      private void importOldBlockDb() {
          loadBlockDb();
  
          PackageManager pm = mContext.getPackageManager();
  
--- 1651,1659 ----
       * Read the old XML-based app block database and import those blockages into the AppOps system.
       */
      private void importOldBlockDb() {
+ 
          loadBlockDb();
+         loadHaloBlockDb();
  
          PackageManager pm = mContext.getPackageManager();
  
